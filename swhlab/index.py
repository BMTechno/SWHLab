"""
code related to generating HTML index of collections of ABFs
"""

import logging
import os
import style
import shutil
import image
import version
from abf import abfProtocol

def filesByExtension(fnames):
    """given a list of files, return a dict organized by extension."""
    byExt={"abf":[],"jpg":[],"tif":[]} # prime it with empties
    for fname in fnames:
        ext = os.path.splitext(fname)[1].replace(".",'').lower()
        if not ext in byExt.keys():
            byExt[ext]=[]
        byExt[ext]=byExt[ext]+[fname]
    return byExt
                    
def findCells(fnames):
    """
    given a list of files, return a list of cells by their ID.
    A cell is indicated when an ABF name matches the start of another file.
    
    Example:
        123456.abf
        123456-whatever.tif 
    """
    IDs=[]
    filesByExt = filesByExtension(fnames)
    for abfFname in filesByExt['abf']:
        ID=os.path.splitext(abfFname)[0]
        for picFname in filesByExt['jpg']+filesByExt['tif']:
            if picFname.startswith(ID):
                IDs.append(ID)
                break
    return smartSort(IDs)
    
def filesByCell(fnames,cells):
    """given files and cells, return a dict of files grouped by cell."""
    byCell={}
    fnames=smartSort(fnames)
    days = list(set([elem[:5] for elem in fnames if elem.endswith(".abf")])) # so pythonic!
    for day in smartSort(days):
        parent=None
        for i,fname in enumerate([elem for elem in fnames if elem.startswith(day) and elem.endswith(".abf")]):
            ID=os.path.splitext(fname)[0]
            if len([x for x in fnames if x.startswith(ID)])-1:
                parent=ID
            if not parent in byCell:
                byCell[parent]=[]
            byCell[parent]=byCell[parent]+[fname]
    return byCell
    
def smartSort(IDs):
    """
    given a list of goofy ABF names, return it sorted intelligently.
    This places things like 16o01001 after 16901001.
    """
    IDs=list(IDs)
    monO=[]
    monN=[]
    monD=[]
    good=[]
    for ID in IDs:
        if ID is None:
            continue
        if 'o' in ID:
            monO.append(ID)
        elif 'n' in ID:
            monN.append(ID)
        elif 'd' in ID:
            monD.append(ID)
        else:
            good.append(ID)
    return sorted(good)+sorted(monO)+sorted(monN)+sorted(monD)
    
class ABFindex:
    def __init__(self,abfFolder,loglevel=logging.DEBUG):
        """
        This class allows indexing of ABFs in directories.
        
        Cell organization:
            Experiments are intended to place all their ABFs in the same 
            directory, with a new cell designated by a file ending in .TIF 
            matching the same name of a file ending in .abf.
        
        Naming convension:
            abfFolder (./) has the ABFs
                fnames - all the files in this folder
                abfnames - all the abf files in this folder
                cells - all the cell IDs
            abfFolder2 (./swhlab/) has data generated by these scripts
                fnames2 - all the files in this folder
                
        Notes:
            the term ID is used to define the name of a cell as the filename
            of its first abf without the abf extension. i.e., 16o01009
        
        """
        self.log = logging.getLogger("swhlab INDEX")
        self.log.setLevel(loglevel)
        if not os.path.isdir(abfFolder):
            self.log.error("not a folder! [%s]",abfFolder)
        else:
            self.folderScan(abfFolder)
        
    def folderScan(self,abfFolder=None):
        """populate class properties relating to files in the folder."""
        if abfFolder is None and 'abfFolder' in dir(self):
            abfFolder=self.abfFolder
        else:
            self.abfFolder=abfFolder
        self.abfFolder=os.path.abspath(self.abfFolder)
        self.log.info("scanning [%s]",self.abfFolder)
        if not os.path.exists(self.abfFolder):
            self.log.error("path doesn't exist: [%s]",abfFolder)
            return
        self.abfFolder2=os.path.abspath(self.abfFolder+"/swhlab/")
        if not os.path.exists(self.abfFolder2):
            self.log.error("./swhlab/ doesn't exist. creating it...")            
            os.mkdir(self.abfFolder2)
        self.fnames=os.listdir(self.abfFolder)
        self.fnames2=os.listdir(self.abfFolder2)
        self.log.debug("./ has %d files",len(self.fnames))
        self.log.debug("./swhlab/ has %d files",len(self.fnames2))
        self.fnamesByExt = filesByExtension(self.fnames)
        if not "abf" in self.fnamesByExt.keys():
            self.log.error("no ABF files found")
        self.log.debug("found %d ABFs",len(self.fnamesByExt["abf"]))
        
        self.cells=findCells(self.fnames) # list of cells by their ID
        self.log.debug("found %d cells"%len(self.cells))
        
        self.fnamesByCell = filesByCell(self.fnames,self.cells) # only ABFs
        self.log.debug("grouped cells by number of source files: %s"%\
            str([len(self.fnamesByCell[elem]) for elem in self.fnamesByCell]))

    def html_index(self,launch=False,showChildren=False):
        """
        generate list of cells with links. keep this simple.
        automatically generates splash page and regnerates frames.
        """
        self.makePics() # ensure all pics are converted
        # generate menu
        html='<a href="index_splash.html" target="content">./%s/</a><br>'%os.path.basename(self.abfFolder)
        for ID in smartSort(self.fnamesByCell.keys()):
            link=''
            if ID+".html" in self.fnames2:
                link='href="%s.html" target="content"'%ID
            html+=('<a %s>%s</a><br>'%(link,ID)) # show the parent ABF (ID)
            if showChildren:
                for fname in self.fnamesByCell[ID]:
                    thisID=os.path.splitext(fname)[0]
                    files2=[x for x in self.fnames2 if x.startswith(thisID) and not x.endswith(".html")]
                    html+='<i>%s</i>'%thisID # show the child ABF
                    if len(files2):
                        html+=' (%s)'%len(files2) # show number of supporting files
                    html+='<br>'
                html+="<br>"
        style.save(html,self.abfFolder2+"/index_menu.html")
        self.html_index_splash() # make splash page
        style.frames(self.abfFolder2+"/index.html",launch=launch) # make frameset
        
    def html_index_splash(self):
        """generate landing page."""
        html="""<h1 style="background-color: #EEEEFF; padding: 10px; border: 1px solid #CCCCFF;">
        SWHLab <span style="font-size: 35%%;">%s<?span></h1>
        """%version.__version__
        #html+='<code>%s</code><br><br>'%self.abfFolder
        #html+='<hr>'
        for parent in smartSort(self.fnamesByCell.keys()):
            html+='<br><b><a href="%s.html">%s</a></b><br>'%(parent,parent)
            for child in self.fnamesByCell[parent]:
                fullpath=os.path.join(self.abfFolder,child)
                protocol = abfProtocol(fullpath)
                html+='<code>%s[%s]</code><br>'%(fullpath,protocol)
        style.save(html,self.abfFolder2+"/index_splash.html")
        return
        
    def html_single_basic(self,ID):
        """
        generate ./swhlab/xxyxxzzz.html for a single given abf.
        Input can be an ABF file path of ABF ID.
        """
        if not ID in self.cells:
            self.log.error("ID [%s] not seen!",ID)
            return
        htmlFname=os.path.abspath(self.abfFolder2+"/"+ID+".html")
        html="<h1>Data for ID %s</h1>"%ID
        npics=0
        for childID in [os.path.splitext(x)[0] for x in self.fnamesByCell[ID]]:
            pics=[x for x in self.fnames2 if x.startswith(childID) and os.path.splitext(x)[1].lower() in [".png",".jpg"]]
            html+="<code>%s</code><br>"%(os.path.abspath(self.abfFolder+'/'+childID+".abf"))
            for i,pic in enumerate(pics):
                html+='<a href="%s"><img class="datapic" src="%s" width="200"></a>'%(pic,pic)
                npics+=1
            html+="<br><br><br>"
        style.save(html,htmlFname)
        self.log.info("created %s containing %d pictures",htmlFname,npics)
    
    def html_single_fixed(self,ID):
        """Single page generator designed for easy gruop comparisons."""
        return
        
    def html_singleAll(self,template="basic"):
        """generate a data view for every ABF in the project folder."""
        for fname in smartSort(self.cells):
            if template=="fixed":
                self.html_single_fixed(fname)
            else:
                self.html_single_basic(fname)
            
    def makePics(self):
        """convert every .image we find to a ./swhlab/ image"""
        rescanNeeded=False
        for fname in smartSort(self.fnames):
            if fname in self.fnames2:
                continue
            ext=os.path.splitext(fname)[1].lower()
            if ext in [".jpg",".png"]:
                if not fname in self.abfFolder2:
                    self.log.debug("copying %s",fname)
                    shutil.copy(os.path.join(self.abfFolder,fname),os.path.join(self.abfFolder2,fname))
                    rescanNeeded=True
            if ext in [".tif",".tiff"]:
                if not fname+".jpg" in self.fnames2:
                    self.log.debug("converting %s",fname)
                    image.TIF_to_jpg(os.path.join(self.abfFolder,fname),saveAs=os.path.join(self.abfFolder2,fname+".jpg"))
                    rescanNeeded=True
        if rescanNeeded:
            self.log.debug("new pics, so a rescan is needed...")
            self.log.debug("REBUILDING ALL RECOMMENDED!!!!!!!!!!!")
            self.folderScan()
                

if __name__=="__main__":    
    index=ABFindex(r'C:\Users\scott\Documents\important\abfs')
    #index=ABFindex(r'C:\Users\swharden\Desktop\limited')
    index.html_index(True)
    index.html_singleAll()
    print("DONE")