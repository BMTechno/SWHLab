"""
code related to generating HTML index of collections of ABFs
"""

import logging
import os
import style

#TODO: move this somewhere more intelligent
logging.basicConfig(format='%(asctime)s\t%(levelname)s\t%(message)s', 
                    datefmt='%m/%d/%Y %I:%M:%S %p', 
                    level=logging.DEBUG)  # change this when distributing

def filesByExtension(fnames):
    """given a list of files, return a dict organized by extension."""
    byExt={"abf":[],"jpg":[],"tif":[]} # prime it with empties
    for fname in fnames:
        ext = os.path.splitext(fname)[1].replace(".",'').lower()
        if not ext in byExt.keys():
            byExt[ext]=[]
        byExt[ext]=byExt[ext]+[fname]
    return byExt
                    
def findCells(fnames):
    """
    given a list of files, return a list of cells by their ID.
    A cell is indicated when an ABF name matches the start of another file.
    
    Example:
        123456.abf
        123456-whatever.tif 
    """
    IDs=[]
    filesByExt = filesByExtension(fnames)
    for abfFname in filesByExt['abf']:
        ID=os.path.splitext(abfFname)[0]
        for picFname in filesByExt['jpg']+filesByExt['tif']:
            if picFname.startswith(ID):
                IDs.append(ID)
                break
    return smartSort(IDs)
    
def filesByCell(fnames,cells):
    """given files and cells, return a dict of files grouped by cell."""
    byCell={}
    fnames=smartSort(fnames)
    days = list(set([elem[:5] for elem in fnames if elem.endswith(".abf")])) # so pythonic!
    for day in smartSort(days):
        parent=None
        for i,fname in enumerate([elem for elem in fnames if elem.startswith(day) and elem.endswith(".abf")]):
            ID=os.path.splitext(fname)[0]
            if len([x for x in fnames if x.startswith(ID)])-1:
                parent=ID
            if not parent in byCell:
                byCell[parent]=[]
            byCell[parent]=byCell[parent]+[fname]
    return byCell
    
def smartSort(IDs):
    """
    given a list of goofy ABF names, return it sorted intelligently.
    This places things like 16o01001 after 16901001.
    """
    monO=[]
    monN=[]
    monD=[]
    good=[]
    for ID in IDs:
        if 'o' in ID:
            monO.append(ID)
        elif 'n' in ID:
            monN.append(ID)
        elif 'd' in ID:
            monD.append(ID)
        else:
            good.append(ID)
    return sorted(good)+sorted(monO)+sorted(monN)+sorted(monD)
    
class ABFindex:
    def __init__(self,abfFolder,loglevel=logging.DEBUG):
        """
        This class allows indexing of ABFs in directories.
        
        Cell organization:
            Experiments are intended to place all their ABFs in the same 
            directory, with a new cell designated by a file ending in .TIF 
            matching the same name of a file ending in .abf.
        
        Naming convension:
            abfFolder (./) has the ABFs
                fnames - all the files in this folder
                abfnames - all the abf files in this folder
                cells - all the cell IDs
            abfFolder2 (./swhlab/) has data generated by these scripts
                fnames2 - all the files in this folder
                
        Notes:
            the term ID is used to define the name of a cell as the filename
            of its first abf without the abf extension. i.e., 16o01009
        
        """
        self.log = logging.getLogger("swhlab INDEX")
        self.log.setLevel(loglevel)
        self.folderScan(abfFolder)
        return
        
    def folderScan(self,abfFolder=None):
        """populate class properties relating to files in the folder."""
        if abfFolder is None and 'abfFolder' in dir(self):
            abfFolder=self.abfFolder
        else:
            self.abfFolder=abfFolder
        self.abfFolder=os.path.abspath(self.abfFolder)
        self.log.info("scanning [%s]",self.abfFolder)
        if not os.path.exists(self.abfFolder):
            self.log.error("path doesn't exist: [%s]",abfFolder)
            return
        self.abfFolder2=os.path.abspath(self.abfFolder+"/swhlab/")
        if not os.path.exists(self.abfFolder2):
            self.log.error("./swhlab/ doesn't exist. creating it...")            
            os.mkdir(self.abfFolder2)
        self.fnames=os.listdir(self.abfFolder)
        self.fnames2=os.listdir(self.abfFolder2)
        self.log.debug("./ has %d files",len(self.fnames))
        self.log.debug("./swhlab/ has %d files",len(self.fnames2))
        self.fnamesByExt = filesByExtension(self.fnames)
        if not "abf" in self.fnamesByExt.keys():
            self.log.error("no ABF files found")
        self.log.debug("found %d ABFs",len(self.fnamesByExt["abf"]))
        
        self.cells=findCells(self.fnames) # list of cells by their ID
        self.log.debug("found %d cells"%len(self.cells))
        
        self.fnamesByCell = filesByCell(self.fnames,self.cells) # only ABFs
        self.log.debug("grouped cells by number of source files: %s"%\
            str([len(self.fnamesByCell[elem]) for elem in self.fnamesByCell]))

    def html_index(self,launch=False,showChildren=False):
        """
        generate list of cells with links. keep this simple.
        automatically generates splash page and regnerates frames.
        """
        
        # generate menu
        html=''
        for ID in smartSort(self.fnamesByCell.keys()):
            link=''
            if ID+".html" in self.fnames2:
                link='href="%s.html" target="content"'%ID
            html+=('<b><a %s>%s</a></b><br>'%(link,ID)) # show the parent ABF (ID)
            if showChildren:
                for fname in self.fnamesByCell[ID]:
                    thisID=os.path.splitext(fname)[0]
                    files2=[x for x in self.fnames2 if x.startswith(thisID) and not x.endswith(".html")]
                    html+='<i>%s</i>'%thisID # show the child ABF
                    if len(files2):
                        html+=' (%s)'%len(files2) # show number of supporting files
                    html+='<br>'
                html+="<br>"
        style.save(html,self.abfFolder2+"/index_menu.html")
        
        # generate splash page
        html='<h1>SWHLab</h1>'
        style.save(html,self.abfFolder2+"/index_splash.html")
        
        # generate frameset
        style.frames(self.abfFolder2+"/index.html",launch=launch)
        
    def html_index_splash(self):
        """generate landing page."""
        
    def html_single(self,ID):
        """
        generate ./swhlab/xxyxxzzz.html for a single given abf.
        Input can be an ABF file path of ABF ID.
        """
        if not ID in self.cells:
            self.log.error("ID [%s] not seen!",ID)
            return
        htmlFname=os.path.abspath(self.abfFolder2+"/"+ID+".html")
        html="<h1>Data for ID %s</h1>"%ID
        npics=0
        for childID in [os.path.splitext(x)[0] for x in self.fnamesByCell[ID]]:
            pics=[x for x in self.fnames2 if x.startswith(childID) and x.endswith(".png")]
            html+="<code>%s</code><br>"%(os.path.abspath(self.abfFolder+'/'+childID+".abf"))
            for i,pic in enumerate(sorted(pics)):
                html+='<img src="%s" width="200">'%pic
                npics+=1
            html+="<br><br><br>"
        style.save(html,htmlFname)
        self.log.info("created %s containing %d pictures",htmlFname,npics)
    
    def html_singleAll(self):
        """generate a data view for every ABF in the project folder."""
        for fname in smartSort(self.cells):
            self.html_single(fname)

if __name__=="__main__":
    index=ABFindex(r'C:\Users\scott\Documents\important\abfs')
    index.html_singleAll()
    index.html_index(True)
    print("DONE")